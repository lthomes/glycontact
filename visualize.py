import seaborn as sns
import plotly.express as px
import pandas as pd
import math
import numpy as np
import matplotlib.pyplot as plt
import imageio
import os
from scipy.cluster import hierarchy
from collections import Counter
from process import *


def atom_contact_map(act, export='', size = 0.5) :
	### shows an atom_contact_map as heatmap using an atom_contact_table created by make_atom_contact_table()
	# act : the atom_contact_table, a dataframe generated by make_atom_contact_table()
	# export : name of the exported figure if any
	# size = text size

	sns.set(font_scale=size)

	sns_plot = sns.heatmap(act,xticklabels=True,yticklabels=True)
	y_labels = sns_plot.get_xticklabels()

	# Modify y-labels (process on the fly)
	new_y_labels = [f"{label.get_text()}" for label in y_labels]

	# Set the modified y-labels back to the clustermap
	sns_plot.set_yticklabels(new_y_labels, rotation=0)

	if export != '' :
		sns_plot.figure.savefig(export)

	plt.show()

def monosaccharide_contact_map(mct, export='', size = 0.5):
	### shows an monosaccharide_contact_map as heatmap using an monosaccharide_contact_table created by make_monosaccharide_contact_table()
	# mct : the monosaccharide_contact_table, a dataframe generated by make_monosaccharide_contact_table()
	# export : name of the exported figure if any
	# size = text size
	sns.set(font_scale=size)
	hm = sns.heatmap(mct,xticklabels=True,yticklabels=True)
	y_labels = hm.get_xticklabels()

	# Modify y-labels (process on the fly)
	new_y_labels = [f"{label.get_text()}" for label in y_labels]

	# Set the modified y-labels back to the clustermap
	hm.set_yticklabels(new_y_labels, rotation=0)

	if export != '' :
		hm.figure.savefig(export)

	plt.show()


def make_gif(prefix,suffix):
    ### Create a gif using multiple PNG files
    # prefix: prefix to include in the filename of the gif output
    # suffix: string that must be present in all PNG to combine before the '.png' extension

    input_path = os.getcwd()
    
    # Set the output path and filename for the GIF
    output_path = prefix + '_animation.gif'

    # Get the list of PNG files in the input directory
    png_files = [f for f in os.listdir(input_path) if f.endswith(suffix+'.png')]

    # Sort the files to ensure the correct order
    png_files.sort()

    # Create a list to store the images
    images = []

    # Read each PNG file and append it to the images list
    for png_file in png_files:
        file_path = os.path.join(input_path, png_file)
        images.append(imageio.imread(file_path))

    # Save the list of images as a GIF animation
    imageio.mimsave(output_path, images, duration=0.2, loop=0)  # Adjust the duration as needed


def show_correlations(corr_df,font_size=1):
    ### Uses a correlation matrix as dataframe (corr_df) to represent it as a heatmap

    sns.set(font_scale=font_size)
    # Visualize the correlation matrix as a heatmap
    plt.figure(figsize=(10, 8))
    sns.heatmap(corr_df, cmap='coolwarm', annot=True, fmt=".2f", linewidths=.5)
    plt.title('Correlation Matrix of Distances')
    plt.show()


def show_correlation_dendrogram(corr_df, font_size = 1):
    ### Create a hierarchical clustering dendrogram from a correlation matrix as dataframe (corr_df)
    
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    dendrogram = hierarchy.dendrogram(hierarchy.linkage(corr_df.values, method='ward'),
                                    labels=corr_df.columns,
                                    leaf_rotation=90,
                                    leaf_font_size=8,ax=ax
                                    )
    for d in dendrogram :
        print(d + str(dendrogram[d]))
    monolist = dendrogram['ivl']
    clustlist = dendrogram['leaves_color_list']
    uniclustlist =list(set(clustlist))
    res_dict = {}
    for c in uniclustlist :
        res_dict[c] = []
    for x in range(0,len(monolist)):
        res_dict[clustlist[x]].append(monolist[x])
    ax.tick_params(axis='x', which='major', labelsize=font_size)
    plt.title('Hierarchical Clustering Dendrogram')
    plt.xlabel('Residue')
    plt.ylabel('Distance')
    plt.show()
    return(res_dict)

def plot_monosaccharide_unstability(variability_table, format='png'):
    # plot monolink variability for all clusters of a given glycan
    # possible formats: png, pdf
    residue_overall_stability = {}
    for c in variability_table.columns.to_list():
        residue_overall_stability[c] = sum(variability_table[c].to_list())

    sorted_residue_overall_stability = sorted(residue_overall_stability.items(), key=lambda x:x[1])
    print(sorted_residue_overall_stability)
    labels, values = zip(*sorted_residue_overall_stability)
    
    fig, ax = plt.subplots(figsize=(12, 6))

    # Cr√©er le graphique
    plt.bar(labels, values)
    plt.xlabel('Monosaccharides')
    plt.ylabel('Variability score')
    plt.xticks(rotation=90)

    fig.subplots_adjust(bottom=0.25)

    # Save the plot as PNG
    if format == 'png' :
        fig.savefig(g+'_instabilities.png')

    # Save the plot as PDF
    if format == 'pdf' :
        fig.savefig(g+'_instabilities.pdf')
        
    plt.show()