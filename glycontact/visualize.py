import seaborn as sns
import networkx as nx
import pandas as pd
import math
import numpy as np
import matplotlib.pyplot as plt
import imageio
import os
import py3Dmol
from io import BytesIO
from pathlib import Path
from scipy.cluster import hierarchy
from collections import Counter
from IPython.display import Image, display, HTML
from glycontact.process import (inter_structure_variability_table, get_structure_graph,
                                monosaccharide_preference_structure, map_dict, get_example_pdb, extract_3D_coordinates)
from glycowork.motif.draw import GlycoDraw
from glycowork.motif.processing import canonicalize_iupac


def draw_contact_map(act, filepath='', size = 0.5, return_plot=False) :
        ### shows an atom_contact_map as heatmap using an atom_contact_table created by make_atom_contact_table()
        # act : the atom_contact_table, a dataframe generated by make_atom_contact_table()
        # export : name of the exported figure if any
        # size = text size
        sns.set(font_scale=size)
        heatmap = sns.heatmap(act,xticklabels=True,yticklabels=True, cmap="magma")
        heatmap.set_yticklabels(heatmap.get_xticklabels(), rotation=0)
        if filepath:
                plt.savefig(filepath, dpi = 300, bbox_inches='tight')
        if return_plot:
                return heatmap
        else:
                plt.show()


def make_gif(prefix, tables):
    ### Create a gif using multiple PNG files
    # prefix: prefix to include in the filename of the gif output
    # tables: result for each frame
    output_path = f'{prefix}_animation.gif'
    images = []
    for table in tables:
        ax = draw_contact_map(table, return_plot=True)
        fig = ax.figure
        buf = BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        images.append(imageio.imread(buf))
        plt.close(fig)  # Clean up memory
    if images:
        imageio.mimsave(output_path, images, duration=0.2, loop=0)
        display(Image(filename=output_path))


def show_correlations(corr_df,font_size=1):
    ### Uses a correlation matrix as dataframe (corr_df) to represent it as a heatmap
    sns.set(font_scale=font_size)
    # Visualize the correlation matrix as a heatmap
    plt.figure(figsize=(10, 8))
    sns.heatmap(corr_df, cmap='coolwarm', annot=True, fmt=".2f", linewidths=.5)
    plt.title('Correlation Matrix of Distances')
    plt.tight_layout()
    plt.show()


def show_correlation_dendrogram(corr_df, font_size = 1):
    ### Create a hierarchical clustering dendrogram from a correlation matrix as dataframe (corr_df)
    plt.figure(figsize=(10, 8))
    linkage = hierarchy.linkage(corr_df.values, method='ward')
    dendrogram = hierarchy.dendrogram(
        linkage, labels=corr_df.columns,
        leaf_rotation=90, leaf_font_size=8
    )
    # Group results by cluster
    monolist = dendrogram['ivl']
    clustlist = dendrogram['leaves_color_list']
    res_dict = {color: [] for color in set(clustlist)}
    for mono, clust in zip(monolist, clustlist):
        res_dict[clust].append(mono)
    plt.tick_params(axis='x', which='major', labelsize=font_size)
    plt.title('Hierarchical Clustering Dendrogram')
    plt.xlabel('Residue')
    plt.ylabel('Distance')
    plt.tight_layout()
    plt.show()
    return res_dict


def plot_monosaccharide_instability(glycan, format='png', mode='sum'):
    # plot monolink variability for all clusters of a given glycan
    # possible formats: png, pdf
    # mode: sum, mean
    variability_table = inter_structure_variability_table(glycan)
    stability_scores = (variability_table.sum() if mode == 'sum' 
                       else variability_table.mean())
    sorted_scores = sorted(stability_scores.items(), key=lambda x: x[1])
    labels, values = zip(*sorted_scores)
    plt.figure(figsize=(12, 6))
    plt.bar(labels, values)
    plt.xlabel('Monosaccharides')
    plt.ylabel('Variability score')
    plt.xticks(rotation=90)
    plt.tight_layout()
    if format in ('png', 'pdf'):
        plt.savefig(f'{glycan}_instabilities.{format}')
    plt.show()


def plot_glycan_score(glycan, score_list=[], attribute="SASA", filepath='') :
    ### Displays a given glycan and highlights monosaccharides using a score list
    # score_list : list of raw values used to highlight monosaccharides (example: mean SASA score, standard deviation...)
    glycan = canonicalize_iupac(glycan)
    if not score_list:
        ggraph = get_structure_graph(glycan)
        scores = np.array(list(nx.get_node_attributes(ggraph, attribute).values()))
    else:
        scores = np.array(score_list[:-1])  # Remove -R value
    # Normalize scores
    score_range = scores.max() - scores.min()
    normalized_scores = (scores - scores.min()) / score_range if score_range > 0 else np.zeros_like(scores)
    filepath = f"{filepath}{glycan}_highlighted.pdf" if filepath else ''
    return GlycoDraw(glycan, per_residue=normalized_scores.tolist(), filepath=filepath)


def show_monosaccharide_preference_structure(df, monosaccharide, threshold, mode='default'):
  #df must be a monosaccharide distance table correctly reanotated
  #mode can be 'default' (check individual monosaccharides in glycan), 'monolink' (check monosaccharide-linkages in glycan), 'monosaccharide' (check monosaccharide types)
  res_dict = monosaccharide_preference_structure(df, monosaccharide, threshold, mode)
  value_counts = Counter(res_dict.values())
  # Plotting the histogram
  plt.bar(value_counts.keys(), value_counts.values())
  plt.xlabel('Values')
  plt.ylabel('Frequency')
  plt.title(f'Frequency of Encountered Values for {monosaccharide} above {threshold}')
  plt.tight_layout()
  plt.show()


def add_snfg_symbol(view, center, mono_name, alpha=1.0):
    """Add 3D-SNFG symbol at the center of a monosaccharide.
    Args:
        view: py3Dmol view object
        center: numpy array of x,y,z coordinates
        mono_name: Name of monosaccharide (e.g., 'Neu5Ac', 'Gal', 'GlcNAc')
        is_ref: Whether this is the reference structure (affects color scheme)
    """
    # Define SNFG mapping (monosaccharide to shape and color)
    snfg_map = {
        'Neu5Ac': {'shape': 'diamond', 'color': '#A15989'},  # Purple diamond for sialic acid
        'Neu5Gc': {'shape': 'diamond', 'color': '#91D3E3'},  # Turqoise diamond for sialic acid
        'GlcNAc': {'shape': 'cube', 'color': '#0385AE'},     # Blue cube for N-acetylglucosamine
        'GalNAc': {'shape': 'cube', 'color': '#FCC326'},     # Yellow cube for N-acetylgalactosamine
        'Gal': {'shape': 'sphere', 'color': '#FCC326'},      # Yellow sphere for galactose
        'Glc': {'shape': 'sphere', 'color': '#0385AE'},      # Blue sphere for glucose
        'Man': {'shape': 'sphere', 'color': '#058F60'},      # Green sphere for mannose
        'Fuc': {'shape': 'cone', 'color': '#C23537'},     # Red triangle for fucose
        'Rha': {'shape': 'cone', 'color': '#058F60'}     # Green triangle for rhamnose
    }
    if mono_name not in snfg_map:
        return  # Skip if monosaccharide not in mapping
    symbol_spec = snfg_map[mono_name]
    color = symbol_spec['color']
    # Make reference structure slightly transparent to distinguish
    # Add the appropriate shape based on SNFG specification
    if symbol_spec['shape'] == 'sphere':
        view.addSphere({
            'center': {'x': center[0], 'y': center[1], 'z': center[2]},
            'radius': 0.5,  # Larger than atom spheres
            'color': color,
            'alpha': alpha
        })
    elif symbol_spec['shape'] == 'cube':
        # Create cube using eight vertices and faces
        size = 0.8  # Size of cube
        view.addBox({
            'center': {'x': center[0], 'y': center[1], 'z': center[2]},
            'dimensions': {'w': size, 'h': size, 'd': size},
            'color': color,
            'alpha': alpha
        })
    elif symbol_spec['shape'] == 'diamond':
        # Create an octahedron (diamond) using cylinders for edges
        size = 0.6  # Adjust size
        # Define the six vertices of an octahedron relative to the center
        vertices = np.array([
            [center[0] + size, center[1], center[2]],       # +X
            [center[0] - size, center[1], center[2]],       # -X
            [center[0], center[1] + size, center[2]],       # +Y
            [center[0], center[1] - size, center[2]],       # -Y
            [center[0], center[1], center[2] + size],       # +Z
            [center[0], center[1], center[2] - size]        # -Z
        ])
        # Define the 12 edges by specifying pairs of vertices
        edges = [
            (0, 2), (0, 3), (0, 4), (0, 5),
            (1, 2), (1, 3), (1, 4), (1, 5),
            (2, 4), (2, 5),
            (3, 4), (3, 5)
        ]
        # First add surface for filled faces
        vertices_list = vertices.tolist()
        faces = [
            [0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2],  # Right half
            [1, 2, 4], [1, 4, 3], [1, 3, 5], [1, 5, 2]   # Left half
        ]
        # Then add thinner cylinders for edges
        for edge in edges:
            start = vertices[edge[0]]
            end = vertices[edge[1]]
            view.addCylinder({
                'start': {'x': start[0], 'y': start[1], 'z': start[2]},
                'end': {'x': end[0], 'y': end[1], 'z': end[2]},
                'radius': 0.1,
                'color': color,
                'opacity': alpha
            })
    elif symbol_spec['shape'] == 'cone':
        # Create a cone using addArrow
        size = 0.6  # Adjust size
        height = size * 1.5
        radius = size / 2
        # Define the direction of the cone (e.g., along the +Z axis)
        direction = np.array([0, 1, 0])
        # Define start and end points
        start = center.tolist()
        end = (center + direction * height).tolist()
        view.addArrow({
            'start': {'x': start[0], 'y': start[1], 'z': start[2]},
            'end': {'x': end[0], 'y': end[1], 'z': end[2]},
            'radius': radius,  # Controls the base radius of the cone
            'mid': 0.01,      # Make arrow almost entirely cone
            'color': color,
            'alpha': alpha,
            'resolution': 32  # Higher resolution for smoother cone
        })


def _do_3d_plotting(coords, labels, view=None, colors=None, bond_color=None, alpha=0.85, show_snfg=True, show_labels=False):
    """Plot a single glycan structure in 3D.
    Args:
        coords: Nx3 array of atomic coordinates
        labels: List of N atom labels (format: "residue_mono_atom")
        view: py3Dmol view object
        colors: Dict mapping atom types to colors
        bond_color: Color for bonds
        alpha: Transparency value
        show_snfg: Whether to show SNFG symbols
        show_labels: Whether to show monosaccharide labels
    """
    if view is None:
            view = py3Dmol.view(width=800, height=800)
    if colors is None:
        colors = {
            'C': '0x0055BB',
            'O': '0x000088',
            'N': '0x88BBFF'
        }
    if bond_color is None:
        bond_color = colors['C']
        
    def get_mono_info(label):
        parts = label.split('_')
        return parts[0], parts[1]
        
    def get_atom_type(label):
        return label.split('_')[-1][0]
        
    # Group atoms by monosaccharide
    mono_groups = {}
    for i, (coord, label) in enumerate(zip(coords, labels)):
        if label.split('_')[-1].startswith('H'):
            continue  # Skip hydrogen atoms
        mono_id, mono_name = get_mono_info(label)
        if mono_id not in mono_groups:
            mono_groups[mono_id] = {'atoms': [], 'center': [], 'name': mono_name}
        atom_name = label.split('_')[-1]
        mono_groups[mono_id]['atoms'].append({
            'coord': coord,
            'name': atom_name,
            'type': get_atom_type(label),
            'idx': i,
            'full_label': label
        })
    # Add atoms and create bonds for each monosaccharide
    for mono_id, group in mono_groups.items():
        atoms = group['atoms']
        mono_name = group['name']
        is_sialic = mono_name in ['SIA', 'NGC']
        # Create lookup for atoms by name
        atom_lookup = {atom['name']: atom for atom in atoms}
        # Add atoms with proper coloring
        for atom in atoms:
            view.addSphere({
                'center': {'x': atom['coord'][0], 'y': atom['coord'][1], 'z': atom['coord'][2]},
                'radius': 0.25,
                'color': colors[atom['type']],
                'alpha': alpha
            })
        # Handle ring bonds
        ring_atoms = ['C2', 'C3', 'C4', 'C5', 'C6'] if is_sialic else ['C1', 'C2', 'C3', 'C4', 'C5']
        for i in range(len(ring_atoms)-1):
            if ring_atoms[i] in atom_lookup and ring_atoms[i+1] in atom_lookup:
                c1 = atom_lookup[ring_atoms[i]]['coord']
                c2 = atom_lookup[ring_atoms[i+1]]['coord']
                view.addCylinder({
                    'start': {'x': c1[0], 'y': c1[1], 'z': c1[2]},
                    'end': {'x': c2[0], 'y': c2[1], 'z': c2[2]},
                    'radius': 0.08,
                    'color': bond_color,
                    'alpha': alpha
                })
        # Add ring-closing bonds
        if is_sialic:
            if 'O6' in atom_lookup:
                for carbon in ['C2', 'C6']:
                    if carbon in atom_lookup:
                        o6 = atom_lookup['O6']['coord']
                        c = atom_lookup[carbon]['coord']
                        view.addCylinder({
                            'start': {'x': o6[0], 'y': o6[1], 'z': o6[2]},
                            'end': {'x': c[0], 'y': c[1], 'z': c[2]},
                            'radius': 0.08,
                            'color': bond_color,
                            'alpha': alpha
                        })
        else:
            if 'O5' in atom_lookup:
                for carbon in ['C1', 'C5']:
                    if carbon in atom_lookup:
                        o5 = atom_lookup['O5']['coord']
                        c = atom_lookup[carbon]['coord']
                        view.addCylinder({
                            'start': {'x': o5[0], 'y': o5[1], 'z': o5[2]},
                            'end': {'x': c[0], 'y': c[1], 'z': c[2]},
                            'radius': 0.08,
                            'color': bond_color,
                            'alpha': alpha
                        })

        def add_bond(atom1_name, atom2_name):
            if atom1_name in atom_lookup and atom2_name in atom_lookup:
                a1 = atom_lookup[atom1_name]['coord']
                a2 = atom_lookup[atom2_name]['coord']
                view.addCylinder({
                    'start': {'x': a1[0], 'y': a1[1], 'z': a1[2]},
                    'end': {'x': a2[0], 'y': a2[1], 'z': a2[2]},
                    'radius': 0.08,
                    'color': bond_color,
                    'alpha': alpha
                })
        
        # Add all substituent bonds
        for atom in atoms:
            if atom['name'].startswith(('O', 'N')) and not atom['name'] in ['O5', 'O6']:
                carbon_num = atom['name'][-1]
                carbon_name = f'C{carbon_num}'
                if carbon_name in atom_lookup:
                    add_bond(atom['name'], carbon_name)
        # Add specific substituent bonds based on monosaccharide type
        if group['name'] in {'GAL', 'GLC', 'NAG', 'NDG', 'A2G'}:
            add_bond('C5', 'C6')
            add_bond('C6', 'O6')
            if group['name'] in {'NAG', 'NDG', 'A2G'}:
                add_bond('C2', 'N2')
                add_bond('N2', 'C2N')
                add_bond('C2N', 'O2N')
                add_bond('C2N', 'CME')
        elif group['name'] in {'FUC'}:
            add_bond('C5', 'C6')
        elif group['name'] in {'SIA', 'NGC'}:
            # Acetyl group
            add_bond('C5', 'N5')
            add_bond('N5', 'C5N')
            add_bond('C5N', 'O5N')
            add_bond('C5N', 'CME')
            # Glycerol chain
            add_bond('C6', 'C7')
            add_bond('C7', 'O7')
            add_bond('C7', 'C8')
            add_bond('C8', 'O8')
            add_bond('C8', 'C9')
            add_bond('C9', 'O9')
            # Carboxyl group
            add_bond('C2', 'C1')
            add_bond('C1', 'O1A')
            add_bond('C1', 'O1B')
        # Add SNFG symbols and labels if requested
        if all(a in atom_lookup for a in ring_atoms):
            center = np.mean([atom_lookup[a]['coord'] for a in ring_atoms], axis=0)
            mono_groups[mono_id]['center'] = center
            mono_name = map_dict[mono_name][:-2]  # Remove linkage info
            if show_snfg:
                add_snfg_symbol(view, center, mono_name, alpha=alpha)
            if show_labels:
                offset = 1.5 if show_snfg else 1.0
                label_pos = center + np.array([0, 0, offset])
                view.addLabel(mono_name, {
                    'position': {'x': label_pos[0], 'y': label_pos[1], 'z': label_pos[2]},
                    'backgroundColor': bond_color,
                    'fontColor': 'white',
                    'fontSize': 12,
                    'alpha': 0.8
                })
    # Add glycosidic bonds between monosaccharides
    for mono_id1, group1 in mono_groups.items():
        if group1['name'] == 'ROH':
            continue
        connecting_carbon = 'C2' if group1['name'] in ['SIA', 'NGC'] else 'C1'
        c1_atom = next((a for a in group1['atoms'] if a['name'] == connecting_carbon), None)
        if c1_atom:
            min_dist = float('inf')
            closest_o = None
            for mono_id2, group2 in mono_groups.items():
                if mono_id1 != mono_id2:
                    for atom in group2['atoms']:
                        if atom['name'] in ['O1', 'O2', 'O3', 'O4', 'O6']:
                            dist = np.sqrt(np.sum((c1_atom['coord'] - atom['coord'])**2))
                            if dist < min_dist:
                                min_dist = dist
                                closest_o = atom
            if closest_o and min_dist < 4.0:
                view.addCylinder({
                    'start': {'x': c1_atom['coord'][0], 'y': c1_atom['coord'][1], 'z': c1_atom['coord'][2]},
                    'end': {'x': closest_o['coord'][0], 'y': closest_o['coord'][1], 'z': closest_o['coord'][2]},
                    'radius': 0.08,
                    'color': bond_color,
                    'alpha': alpha
                })


def plot_glycan_3D(glycan, stereo=None, view=None, **plot_kwargs):
    """Plot a single glycan structure from its IUPAC sequence.
    
    Args:
        glycan: IUPAC sequence string
        stereo: Optional stereo specification ('alpha' or 'beta'). If None, inferred from sequence.
        view: Optional existing py3Dmol view. If None, creates new view.
        **plot_kwargs: Additional arguments passed to plot_glycan_3D
        
    Returns:
        py3Dmol view object
    """
    # Create view if not provided
    if view is None:
        view = py3Dmol.view(width=800, height=800)
    # Get structure data
    pdb_file = get_example_pdb(glycan, stereo=stereo)
    coords_df = extract_3D_coordinates(pdb_file)
    coords_df = coords_df[~coords_df['atom_name'].str.startswith('H')]
    coords = coords_df[['x', 'y', 'z']].values
    labels = [f"{row['residue_number']}_{row['monosaccharide']}_{row['atom_name']}" 
             for _, row in coords_df.iterrows()]
    # Plot structure
    _do_3d_plotting(coords, labels, view=view, **plot_kwargs)
    # Set view options
    view.setStyle({'sphere': {}})
    view.zoomTo()
    view.render()
    return view


def plot_superimposed_glycans(superposition_result, filepath='', animate=True, rotation_speed=1,
                              show_labels=False, show_snfg=True):
    """Create a 3D plot of superimposed glycan structures.
    Args:
        superposition_result: Output from superimpose_glycans()
        filepath: Optional path to save plot
        show_labels: Whether to show atom labels
    """
    view = py3Dmol.view(width=800, height=800)
    # More contrasting color schemes
    ref_colors = {
        'C': '0x0055BB',  # Strong blue for carbon
        'O': '0x000088',  # Very dark blue for oxygen
        'N': '0x88BBFF'   # Light blue for nitrogen
    }
    mobile_colors = {
        'C': '0xFF6600',  # Bright orange for carbon
        'O': '0xCC3300',  # Dark red-orange for oxygen
        'N': '0xFFBB44'   # Light orange for nitrogen
    }
    # Plot both structures
    _do_3d_plotting(superposition_result['ref_coords'], superposition_result['ref_labels'], view=view,
                   colors=ref_colors, alpha=0.85, show_snfg=show_snfg, show_labels=show_labels)
    _do_3d_plotting(superposition_result['transformed_coords'], superposition_result['mobile_labels'], view=view,
                   colors=mobile_colors, alpha=1.0, show_snfg=show_snfg, show_labels=show_labels)

    # Add RMSD information
    rmsd = superposition_result['rmsd']
    view.addLabel(f'RMSD: {rmsd:.2f} Å', {
        'position': {'x': superposition_result['ref_coords'][0][0],
                    'y': superposition_result['ref_coords'][0][1],
                    'z': superposition_result['ref_coords'][0][2] + 5},
        'backgroundColor': 'black',
        'fontColor': 'white',
        'fontSize': 14
    })
    # Set view options
    view.setStyle({'sphere': {}})
    view.zoomTo()
    view.render()
    if filepath:
        capture_html = f"""
        <button onclick="saveImage()" style="padding: 8px 16px; margin: 10px 0;">Save Image</button>
        <div id="debug_output" style="color: #666;"></div>
        <script>
        function log(msg) {{
            console.log(msg);
            document.getElementById('debug_output').textContent = msg;
        }}
        
        function saveImage() {{
            log('Finding canvas...');
            
            // Try different selectors to find the canvas
            let canvas = document.querySelector('.viewer_3Dmoljs canvas') || 
                        document.querySelector('.mol-container canvas') ||
                        document.querySelector('canvas');
                        
            if (!canvas) {{
                log('Error: No canvas found!');
                return;
            }}
            
            log('Canvas found, getting data URL...');
            
            try {{
                let dataURL = canvas.toDataURL('image/png');
                log('Got data URL, creating download...');
                
                let link = document.createElement('a');
                link.download = '{filepath}';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                log('Download triggered!');
            }} catch (error) {{
                log('Error: ' + error.message);
                console.error(error);
            }}
        }}
        </script>
        """
        display(HTML(capture_html))
        print(f"Click the 'Save Image' button above to save the visualization to {filepath}")
    if animate:
        view.spin(True)
    return view
